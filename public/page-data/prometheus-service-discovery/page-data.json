{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/prometheus-service-discovery","result":{"data":{"brainNote":{"slug":"prometheus-service-discovery","title":"prometheus-service-discovery","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"prometheus-service-discovery\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Prometheus Service Discovery\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NOTE\"), \": It's a raw version, will re-work it soon :clown_face:\")), mdx(\"p\", null, \"Service discovery (SD) enables you to provide that information to Prometheus from whichever database you store it in. Prometheus supports many common sources of service information, such as Consul, Amazon's EC2 and Kubernetes out of the box. If your particular source isn't already supported, you can use the file-based service discovery mechanism to hook it in. This could be by having your configuration management system, such as Ansible or Chef, write the list of machines and services they know about in the right format, or a script running regularly to pull it from whatever data source you use.\"), mdx(\"p\", null, \"[TOC]\"), mdx(\"h2\", null, \"Service Discovery Mechanisms\"), mdx(\"p\", null, \"Service discovery isn't just about you providing a list of machines to Prometheus, or monitoring. It is a more general concern that you will see across your systems; applications need to find their dependencies to talk to, and hardware technicians need to know which machines are safe to turn off and repair.\"), mdx(\"p\", null, \"A good service discovery mechanism will provide you with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"metadata\"), \". Metadata is what you will convert into target labels, and generally the more metadata you have, the better.\"), mdx(\"h3\", null, \"Static\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Static configuration where targets are provided directly in the prometheus.yml.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Combining with a configuration management tool such as Ansible, you could have its templating system write out a list of all the machines it knows about to have their Node exporters scraped.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scape_configs:\\n  - job_name: node\\n    static_configs:\\n      - targets:\\n{% for host ini groups[\\\"all\\\"] %}\\n        - {{ host }}:9100\\n{% endfor %}\\n\")), mdx(\"h3\", null, \"File\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"File SD\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It reads monitoring targets from files you provide on the local filesystem.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"JSON or YAML formats.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n    {\\n        \\\"targets\\\": [\\\"host1:9100\\\", \\\"host2:9100\\\"],\\n        \\\"labels\\\": {\\n            \\\"team\\\": \\\"infra\\\",\\n            \\\"job\\\": \\\"node\\\"\\n        }\\n    },\\n    {\\n        \\\"targets\\\": [\\\"host1:9090\\\"],\\n        \\\"labels\\\": {\\n            \\\"team\\\": \\\"monitoring\\\",\\n            \\\"job\\\": \\\"prometheus\\\"\\n        }\\n    }\\n]\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Issue with JSON format is that the last item in a list or hash cannot have a trailing comma --> using JSON library to generate JSON files rather than trying to do it by hand.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n  - job_name: file\\n    file_sd_configs:\\n      - files:\\n          - '*.json'\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Providing the targets with a file means it could come from templating in a configuration management system, a daemon that writes it out regularly, or even from a web service via a cronjob using wget.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Changes are picked up automatically using inotify.\")), mdx(\"h3\", null, \"Consul\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Consul service discovery is a service discovery mechanism that uses the network.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Consul has an agent that runs on each of your machines, and these gossip amongst themselves. Applications talk only to the local agent on a machine.\")), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://www.consul.io/assets/images/consul-arch-420ce04a.png\",\n    \"alt\": \"Image result for consul architecture\"\n  })), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sample config:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n  - job_name: consul\\n    consul_sd_configs:\\n      - server: 'localhost:8500'\\n\")), mdx(\"h2\", null, \"Relabelling\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Tell Prometheus how to map from metadata to targets using \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"relabelling\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Check \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./labels.md\"\n  }, \"prometheus labels note.\"))), mdx(\"h2\", null, \"Choosing what to scrape\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Which targets you actually want to scrape.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"relabel action\"), \" + \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"regex\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using a keep relabel action to only monitor targets with a team=\\\"infra\\\" label.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n  - job_name: file\\n    file_sd_configs:\\n      - files:\\n         - '*.json'\\n    relabel_configs:\\n      - source_labels: [team]\\n        regex: infra\\n        action: keep\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Two relabel actions requiring contradictory values for the team label.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n  - job_name: file\\n    file_sd_configs:\\n      - files:\\n          - '*.json'\\n    relabel_configs:\\n      - source_labels: [team]\\n        regex: infra\\n        action: keep\\n      - source_labels: [team]\\n        regex: monitoring\\n        action: keep\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using | to allow one label value or another.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n  - job_name: file\\n    file_sd_configs:\\n      - files:\\n          - '*.json'\\n    relabel_configs:\\n      - source_labels: [team]\\n        regex: infra|monitoring\\n        action: keep\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using multiple source labels.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n  - job_name: file\\n    file_sd_configs:\\n      - files:\\n          - '*.json'\\n    relabel_configs:\\n      - source_labels: [job, team]\\n        regex: prometheus;monitoring\\n        action: drop\\n\")), mdx(\"h3\", null, \"Regular expressions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/google/re2/wiki/Syntax\"\n  }, \"RE2\"), \" engine for regular expressions that comes with Go.\")), mdx(\"h2\", null, \"Target labels\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Target labels are labels that are added to the labels of every time series returned from a scrape. They are \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"the identity of your targets\"), \", and accordingly they should not generally vary over time as might be the case with version numbers or machine owners.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It is common to add target labels for the broader scope of the application, such as whether it is in development or production, their region, datacenter, and which team manages them.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Target labels ultimately allow you to select, group, and aggregate targets in PromQL.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Cost: Every addtional label is one more you need to keep in mind for every single PromQL expression you write.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"As a rule of thumb your target labels should be a hierarchy, with each one adding additional distinctiveness\")), mdx(\"h3\", null, \"Replace - How to aggregate monitoring data according to the environment?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using relabelling to specify your target labels: \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"replace action\"), \" - allows you to copy labels around, while also applying regular expressions.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using a replace relabel action to replace team=\\\"monitoring\\\" with team=\\\"monitor\\\"\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n  - job_name: file\\n    file_sd_configs:\\n      - files:\\n          - '*.json'\\n     relabel_configs:\\n       - source_labels: [team]\\n         regex: monitoring\\n         replacement: monitor\\n         target_label: team\\n         action: replace\\n\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using a replace relabel action to remove a trailing from the team label.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n  - job_name: file\\n    file_sd_configs:\\n      - files:\\n          - '*.json'\\n    relabel_configs:\\n      - source_labels: [team]\\n        regex: '(.*)ing'\\n        replacement: '${1}'\\n        target_label: team\\n        action: replace\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using a replace relabel action remove the team label\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n - job_name: file\\n   file_sd_configs:\\n    - files:\\n      - '*.json'\\n   relabel_configs:\\n    - source_labels: []\\n      regex: '(.*)'\\n      replacement: '${1}'\\n      target_label: team\\n      action: replace\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using the defaults to remove the team label succinctly\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n - job_name: file\\n   file_sd_configs:\\n    - files:\\n       - '*.json'\\n   relabel_configs:\\n    - source_labels: []\\n      target_label: team\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using the IP from Consul with port 9100 for the Node exporter\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n - job_name: node\\n   consul_sd_configs:\\n    - server: 'localhost:8500'\\n   relabel_configs:\\n    - source_labels: [__meta_consul_address]\\n      regex: '(.*)'\\n      replacement: '${1}:9100'\\n      target_label: __address__\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Tip\"), \": If relabelling produces 2 identical targets from one of your scrape  configs, they will be deduplicated automatically.\")), mdx(\"h3\", null, \"job, instance and \", \"_\", \"_\", \"address\", \"_\", \"_\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If target has no \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"instance\"), \" label, it is defaulted to the value of the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"__address__\"), \" label.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"instance\"), \" along with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"job\"), \" are two labels targets will always have, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"job\"), \" being defaulted from the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"job_name\"), \" configuration option.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"__address__\"), \" is the host and port Prometheus will connect to when scraping.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Tip\"), \": Prometheus will perform DNS resolution on the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"__address__\"), \" --> provide host:port rather than ip:port\")), mdx(\"h3\", null, \"Labelmap\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"labelmap\"), \" action is different from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"drop\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"keep\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"replace\"), \" actions you have already seen in that it applies to label names rather label values.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Use the EC2 service tag as the job label, with all tags prefixed with monitor\", \"_\", \"as additional target labels.\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n  - job_name: ec2\\n    ec2_sd_configs:\\n      - region: <region>\\n        access_key: <access key>\\n        secret_key: <secret key>\\n    relabel_configs:\\n      - source_labels: [__meta_ec2_tag_service]\\n        target_label: job\\n      - regex: __meta_ec2_public_tag_monitor_(.*)\\n        replacement: '${1}'\\n        action: labelmap\\n\")), mdx(\"h3\", null, \"Lists\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Some service discovery mechanisms just have a list of tags. --> convert a list into key-value metadata. This is done by joining the items in the list with a comma and using the now-joined items as a label value. A comma is also put at the start and the end of the value, to make writing correct regular expressions easier.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Keeping only Consul services with the prod tag\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n - job_name: node\\n   consul_sd_configs:\\n    - server: 'localhost:8500'\\n   relabel_configs:\\n    - source_labels: [__meta_consul_tag]\\n      regex:  '.*,prod,.*'\\n      action: keep\\n\")), mdx(\"h2\", null, \"How to scrape\"), mdx(\"h3\", null, \"Duplicate Jobs\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"job_name\"), \" must be unique, as it is only a default, you are not prevented from having different scrape configs producing targets with the same job label.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For example, if you had some jobs that required a different secretLabel clashes and honor_labels which were indicated by a Consul tag, you could segregate them using keep and drop actions, and then use a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"replace\"), \" to set the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"job\"), \" label\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"- job_name: my_job\\n   consul_sd_configs:\\n    - server: 'localhost:8500'\\n   relabel\\n    - source_labels: [__meta_consul_tag]\\n      regex:  '.*,specialsecret,.*'\\n      action: drop\\n   basic_auth:\\n     username: brian\\n     password: normalSecret\\n\\n - job_name: my_job_special_secret\\n   consul_sd_configs:\\n    - server: 'localhost:8500'\\n   relabel\\n    - source_labels: [__meta_consul_tag]\\n      regex:  '.*,specialsecret,.*'\\n      action: keep\\n    - replacement: my_job\\n      target_label: job\\n   basic_auth:\\n     username: brian\\n     password: specialSecret\\n\")), mdx(\"h3\", null, \"metric\", \"_\", \"label\", \"_\", \"configs\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Check \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./labels.md\"\n  }, \"labels\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"labeldrop\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"labelkeep\"), \": relabel actions that are unlikely to be ever required for target relabelling, but that can come up in metric relabelling.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Similar to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"labelmap\"), \", they apply to label names rather than to label values. Instead of copying labels, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"labeldrop\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"labelkeep\"), \" remove labels.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dropping all scraped labels that begin with node_\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"scrape_configs:\\n - job_name: misbehaving\\n   static_configs:\\n    - targets:\\n       - localhost:1234\\n   metric_relabel_configs:\\n    - regex: 'node_.*'\\n      action: labeldrop\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"About these notes","slug":"about","childMdx":{"excerpt":"Hi, I'm  Kien Nguyen-Tuan  👋. prometheus-promql-gotchas prometheus-prometheus-promql-join prometheus-prometheus-labels-relabel prometheus…"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"@kiennt's notes"}}},"pageContext":{"slug":"prometheus-service-discovery"}},"staticQueryHashes":[]}