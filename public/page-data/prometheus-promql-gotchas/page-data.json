{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/prometheus-promql-gotchas","result":{"data":{"brainNote":{"slug":"prometheus-promql-gotchas","title":"prometheus-promql-gotchas","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"prometheus-promql-gotchas\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"PromQL Gotchas\"), mdx(\"h2\", null, \"Instant vector & Range Vector\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Instant vector\"), \": One value per time series guaranteed.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Range vector\"), \": Any number of values between two timestamps.\")), mdx(\"h2\", null, \"Operators\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Aggregation Operators\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"instant vector -> instant vector\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Binary operators\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"instant vector <operator> instant vector = instant vector\\n\")), mdx(\"h2\", null, \"Functions\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"instant vector -> instant vector\\nrange vector -> instant vector\\n\")), mdx(\"h3\", null, \"Gotchas\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Tell your aggregation operators about the label you care about.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Never compare raw counters - use rate().\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Be careful with label sets when using binary operators.\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://promcon.io/2019-munich/slides/promql-for-mere-mortals.pdf\"\n  }, \"https://promcon.io/2019-munich/slides/promql-for-mere-mortals.pdf\")), mdx(\"h2\", null, \"Filtering by regexps on metric name\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sometimes it is required returning all the time series for multiple metric names.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Metric name is just an ordinary label with a special name - \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"__name__\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For instance, the following query returns all the time series with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"node_network_receive_bytes_total\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"node_network_transmit_bytes_total\"), \":\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"{__name__=~\\\"node_network_(receive|transmit)_bytes_total\\\"}\\n\")), mdx(\"h2\", null, \"Comparing current data with historical data\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"PromQL allows querying historical data and combining / comparing it to the current data with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"offset\"), \".\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"node_network_receive_bytes_total offset 7d\\ngo_memstats_gc_cpu_fraction > 1.5 * (go_memstats_gc_cpu_fraction offset 1h)\\n\")), mdx(\"h2\", null, \"Rate vs irate vs increase vs idelta\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Rate\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(Vcurr - Vprev)/(Tcurr - Tprev)\\nIncrease/(Tcurr - Tprev)\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Irate\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(Vcurr-1 - Vcurr-2)/(Tcurr-1 - Tcurr-2)\\nIdelta / (Tcurr-1 - Tcurr-2)\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Increase\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(Vcurr - Vprev)\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Idelta\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(Vcurr-1 - Vcurr-2)\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/prometheus/prometheus/blob/master/promql/functions.go#L135\"\n  }, \"https://github.com/prometheus/prometheus/blob/master/promql/functions.go#L135\")), mdx(\"h2\", null, \"Combining multiple series\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Combining multiple time series with arithmetic operations requires understanding \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://prometheus.io/docs/prometheus/latest/querying/operators/#vector-matching\"\n  }, \"matching rules\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The matching rules may be augmented with ignoring, on, group_left and group_right modifiers.\")), mdx(\"h2\", null, \"Comparson with bool\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"rate(node_network_receive_bytes_total[5m]) < bool 2300\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1 - true, 0 - false\")), mdx(\"h2\", null, \"Returning multiple results from a single query\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"or\"), \" operator.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"metric1 or metric2 or metric3\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"There is a common trap when combining expression results: results with duplicate set of labels are skipped.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sum(a) or sum(b)\\n// sum(a) and sum(b) have identical label set --> skip sum(b)\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"About these notes","slug":"about","childMdx":{"excerpt":"Hi, I'm  Kien Nguyen-Tuan  ðŸ‘‹. prometheus-promql-gotchas prometheus-prometheus-promql-join prometheus-prometheus-labels-relabel prometheusâ€¦"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"@kiennt's notes"}}},"pageContext":{"slug":"prometheus-promql-gotchas"}},"staticQueryHashes":[]}